import {
  require_axios
} from "./chunk-CIB72QXC.js";
import {
  __publicField,
  __toESM,
  init_shim
} from "./chunk-JBI7JIHS.js";

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/index.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/check.js
init_shim();
function checkInit(target, targetName, msg) {
  if (target === void 0 || target === null) {
    throw new Error(msg || `${targetName || "Variable"} is not inited!`);
  }
}
function checkKey(target, key, targetName, msg) {
  if (!target.has(key)) {
    throw new Error(msg || `${key} not existed in Map ${targetName}!`);
  }
}

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/convert.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/endpoint.js
init_shim();
var import_axios = __toESM(require_axios());
var _getValidEndpoint = async (endpoint, nodeType, logger) => {
  const valid = await isValidEndpoint(endpoint, nodeType, false, logger);
  if (valid === false) {
    return Promise.reject("Invalid endpoint.");
  } else {
    return endpoint;
  }
};
var getFastestEndpoint = async (endpoints, nodeType, logger) => {
  try {
    const fastestEndpoint = await Promise.any(endpoints.map((endpoint) => _getValidEndpoint(endpoint, nodeType, logger)));
    logger == null ? void 0 : logger.debug("rpcEndpoint won the race:", fastestEndpoint);
    return fastestEndpoint;
  } catch (e) {
    return Promise.reject(e);
  }
};
var isValidEndpoint = async (endpoint, nodeType, isLazy, logger) => {
  if (isLazy) {
    logger == null ? void 0 : logger.debug("Skipping test of accessibility for", endpoint);
    return true;
  }
  logger == null ? void 0 : logger.debug("Testing accessibility of", endpoint);
  try {
    let response;
    if (typeof endpoint === "string") {
      response = nodeType === "rest" ? (
        /**
         * The verification process for the Rest API differs from that of RPC.
         * Rather than checking for JSON-RPC availability, we verify the node
         * information is available.
         */
        await import_axios.default.get(`${endpoint}/cosmos/base/tendermint/v1beta1/node_info`)
      ) : (
        /**
         * SigningStargate uses JSON-RPC requests to broadcast transactions.
         * To ensure that the node has this capability, conduct a POST request
         * to the endpoint to verify its accessibility in advance. Note that
         * SigningStargate also performs this internal check.
         */
        await import_axios.default.post(endpoint)
      );
    } else {
      response = nodeType === "rest" ? (
        /**
         * The verification process for the Rest API differs from that of RPC.
         * Rather than checking for JSON-RPC availability, we verify the node
         * information is available.
         */
        await import_axios.default.get(`${endpoint.url}/cosmos/base/tendermint/v1beta1/node_info`, {
          headers: endpoint.headers
        })
      ) : (
        /**
         * SigningStargate uses JSON-RPC requests to broadcast transactions.
         * To ensure that the node has this capability, conduct a POST request
         * to the endpoint to verify its accessibility in advance. Note that
         * SigningStargate also performs this internal check.
         */
        await import_axios.default.post(endpoint.url, {
          headers: endpoint.headers
        })
      );
    }
    if (response.status == 200) {
      logger == null ? void 0 : logger.debug("Access successfully.");
      return true;
    }
  } catch (err) {
    logger == null ? void 0 : logger.debug(`${err.name}: ${err.message}`);
  }
  logger == null ? void 0 : logger.debug("Access failed.");
  return false;
};
var getIsLazy = (globalIsLazy, chainIsLazy, endpointIsLazy, parameterIsLazy, logger) => {
  if (typeof parameterIsLazy !== "undefined") {
    return parameterIsLazy;
  }
  if (typeof endpointIsLazy !== "undefined") {
    return endpointIsLazy;
  }
  if (typeof chainIsLazy !== "undefined") {
    return chainIsLazy;
  }
  if (typeof globalIsLazy !== "undefined") {
    return globalIsLazy;
  }
  return false;
};

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/convert.js
function convertChain(chain, assetLists, signerOptions, preferredEndpoints, isLazy, logger) {
  var _a, _b, _c, _d;
  const chainName = typeof chain === "string" ? chain : chain.chain_name;
  const assetList = assetLists.find((list) => list.chain_name === chainName);
  const _preferredEndpoints = {
    ...preferredEndpoints,
    isLazy: getIsLazy(isLazy, preferredEndpoints == null ? void 0 : preferredEndpoints.isLazy, void 0, void 0, logger)
  };
  const converted = {
    name: chainName,
    chain: typeof chain === "string" ? void 0 : chain,
    assetList,
    clientOptions: {
      stargate: (_a = signerOptions == null ? void 0 : signerOptions.stargate) == null ? void 0 : _a.call(signerOptions, chain),
      signingStargate: (_b = signerOptions == null ? void 0 : signerOptions.signingStargate) == null ? void 0 : _b.call(signerOptions, chain),
      signingCosmwasm: (_c = signerOptions == null ? void 0 : signerOptions.signingCosmwasm) == null ? void 0 : _c.call(signerOptions, chain),
      preferredSignType: ((_d = signerOptions == null ? void 0 : signerOptions.preferredSignType) == null ? void 0 : _d.call(signerOptions, chain)) || "amino"
    },
    preferredEndpoints: _preferredEndpoints
  };
  return converted;
}

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/error.js
init_shim();
var ClientNotExistError = new Error("Client Not Exist!");
var RejectedError = new Error("Request Rejected!");
var ExpiredError = new Error("Expired!");
var WalletNotProvidedError = class extends Error {
  constructor(walletName) {
    super(`Wallet ${walletName} is not provided.`);
    __publicField(this, "walletName");
    this.walletName = walletName;
  }
};
var ConnectError = class extends Error {
  constructor(message) {
    super(message);
    __publicField(this, "name", "ConnectError");
  }
};

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/map.js
init_shim();
function valuesApply(target, callbackfn) {
  return new Map(Array.from(target).map(([key, value]) => [key, callbackfn(value)]));
}

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/math.js
init_shim();
function sum(iterable, callbackfn, initialValue) {
  return Array.from(iterable).reduce(callbackfn, initialValue);
}

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/status.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/index.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/chain.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/common.js
init_shim();
var State;
(function(State2) {
  State2["Init"] = "Init";
  State2["Pending"] = "Pending";
  State2["Done"] = "Done";
  State2["Error"] = "Error";
})(State || (State = {}));

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/hook.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/manager.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/view.js
init_shim();
var ModalView;
(function(ModalView2) {
  ModalView2["WalletList"] = "WalletList";
  ModalView2["Connecting"] = "Connecting";
  ModalView2["Connected"] = "Connected";
  ModalView2["Error"] = "Error";
  ModalView2["NotExist"] = "NotExist";
  ModalView2["Rejected"] = "Rejected";
  ModalView2["QRCode"] = "QRCode";
})(ModalView || (ModalView = {}));

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/types/wallet.js
init_shim();
var WalletStatus;
(function(WalletStatus2) {
  WalletStatus2["Disconnected"] = "Disconnected";
  WalletStatus2["Connecting"] = "Connecting";
  WalletStatus2["Connected"] = "Connected";
  WalletStatus2["NotExist"] = "NotExist";
  WalletStatus2["Rejected"] = "Rejected";
  WalletStatus2["Error"] = "Error";
})(WalletStatus || (WalletStatus = {}));

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/status.js
var getWalletStatusFromState = (state, message) => {
  switch (state) {
    case "Pending":
      return WalletStatus.Connecting;
    case "Done":
      return WalletStatus.Connected;
    case "Error":
      switch (message) {
        case ClientNotExistError.message:
          return WalletStatus.NotExist;
        case RejectedError.message:
          return WalletStatus.Rejected;
        default:
          return WalletStatus.Error;
      }
    case "Init":
      return WalletStatus.Disconnected;
    default:
      return WalletStatus.Disconnected;
  }
};

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/name-service.js
init_shim();

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/config.js
init_shim();
var nameServiceRegistries = [
  {
    name: "icns",
    contract: "osmo1xk0s8xgktn9x5vwcgtjdxqzadg88fgn33p8u9cnpdxwemvxscvast52cdd",
    chainName: "osmosis",
    getQueryMsg: (address) => {
      return {
        icns_names: { address }
      };
    },
    slip173: "osmo"
  },
  {
    name: "stargaze",
    contract: "stars1fx74nkqkw2748av8j7ew7r3xt9cgjqduwn8m0ur5lhe49uhlsasszc5fhr",
    chainName: "stargaze",
    getQueryMsg: (address) => {
      return {
        name: { address }
      };
    },
    slip173: "stars"
  }
];

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/name-service.js
var getNameServiceRegistryFromChainName = (chainName) => {
  const registry = nameServiceRegistries.find((r) => r.chainName === chainName);
  if (!registry) {
    throw new Error("No such name service registered with chain " + chainName);
  }
  return registry;
};
var getNameServiceRegistryFromName = (name) => {
  return nameServiceRegistries.find((r) => r.name === name);
};
var getNameServiceNameFromChainName = (chainName) => {
  var _a;
  return (_a = nameServiceRegistries.find((r) => r.chainName === chainName)) == null ? void 0 : _a.name;
};
var getChainNameFromNameServiceName = (name) => {
  var _a;
  return (_a = nameServiceRegistries.find((r) => r.name === name)) == null ? void 0 : _a.chainName;
};

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/logger.js
init_shim();
function wrap(logLevel, message) {
  switch (logLevel) {
    case "ERROR":
      return [`%c${logLevel} -`, "color: Red;", message];
    case "WARN":
      return [`%c${logLevel} -`, "color: Orange;", message];
    case "INFO":
      return [`%c${logLevel} -`, "color: Blue;", message];
    case "DEBUG":
      return [`%c${logLevel} -`, "color: Purple;", message];
    case "TRACE":
      return [`%c${logLevel} -`, "color: Brown;", message];
  }
}
var Logger = class {
  constructor(level = "INFO") {
    __publicField(this, "logger");
    __publicField(this, "level");
    __publicField(this, "levelOrder", [
      "TRACE",
      "DEBUG",
      "INFO",
      "WARN",
      "ERROR",
      "NONE"
    ]);
    this.logger = console;
    this.level = level;
  }
  compare(a, b) {
    const aindex = this.levelOrder.indexOf(a);
    const bindex = this.levelOrder.indexOf(b);
    if (aindex > bindex) {
      return 1;
    } else if (aindex < bindex) {
      return -1;
    } else {
      return 0;
    }
  }
  trace(message, ...optionalParams) {
    if (this.compare("TRACE", this.level) >= 0) {
      this.logger.trace(...wrap("TRACE", message), ...optionalParams);
    }
  }
  debug(message, ...optionalParams) {
    if (this.compare("DEBUG", this.level) >= 0) {
      this.logger.debug(...wrap("DEBUG", message), ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.compare("INFO", this.level) >= 0) {
      this.logger.info(...wrap("INFO", message), ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.compare("WARN", this.level) >= 0) {
      this.logger.warn(...wrap("WARN", message), ...optionalParams);
    }
  }
  error(message, ...optionalParams) {
    if (this.compare("ERROR", this.level) >= 0) {
      this.logger.error(...wrap("ERROR", message), ...optionalParams);
    }
  }
};

// node_modules/.pnpm/@cosmos-kit+core@2.16.1/node_modules/@cosmos-kit/core/esm/utils/session.js
init_shim();
var Session = class {
  constructor(sessionOptions) {
    __publicField(this, "sessionOptions");
    __publicField(this, "timeoutId");
    this.sessionOptions = sessionOptions;
  }
  update() {
    if (typeof this.timeoutId !== "undefined") {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      var _a, _b;
      (_b = (_a = this.sessionOptions).callback) == null ? void 0 : _b.call(_a);
    }, this.sessionOptions.duration);
  }
};

export {
  State,
  ModalView,
  WalletStatus,
  checkInit,
  checkKey,
  getFastestEndpoint,
  isValidEndpoint,
  getIsLazy,
  convertChain,
  ClientNotExistError,
  RejectedError,
  ExpiredError,
  WalletNotProvidedError,
  ConnectError,
  valuesApply,
  sum,
  getWalletStatusFromState,
  getNameServiceRegistryFromChainName,
  getNameServiceRegistryFromName,
  getNameServiceNameFromChainName,
  getChainNameFromNameServiceName,
  Logger,
  Session
};
//# sourceMappingURL=chunk-FTVSXWGT.js.map
